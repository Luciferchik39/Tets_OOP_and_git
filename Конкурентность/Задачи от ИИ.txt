Блок 1: Фундаментальные основы
Цель: Проверить, понимаешь ли ты базу, которую мы обсуждали.

Вопрос: Объясни простыми словами, чем отличается конкурентность (concurrency) от параллелизма (parallelism). Можно на жизненном примере.

Вопрос: Какие два основных типа задач существуют с точки зрения производительности? Приведи по два примера каждого типа из реальной жизни (не из программирования).

Вопрос: Ты поймал себя на мысли: "Мой Python-скрипт работает слишком медленно". Назови три возможных способа его ускорить (не касаясь смены алгоритма) и для какого типа задач каждый способ подходит.

Блок 2: Многопоточность (Threading) и GIL
Цель: Понять, разобрался ли ты в "ахиллесовой пяте" Python.

Вопрос: Что такое GIL (Global Interpreter Lock)? Для чего он вообще нужен?

Вопрос: Если у меня есть 8-ядерный процессор и я создам 8 потоков в Python для сложения миллиона чисел, будет ли это быстрее, чем в 1 поток? Почему?

Вопрос: Если GIL такой "плохой" и ограничивает потоки, зачем тогда вообще нужен модуль threading? В каких случаях он будет полезен?

Вопрос: Допустим, два потока одновременно пытаются увеличить глобальную переменную counter += 1 на 1000 раз каждый. Почему в конце counter может оказаться не 2000, а, скажем, 1567? Как с этим бороться?

Блок 3: Асинхронность (Asyncio)
Цель: Проверить твое понимание неблокирующего кода.

Вопрос: Ты уже знаешь про event loop. Объясни, как он работает, на примере кафе или ресторана (как мы это делали).

Вопрос: В чем разница между time.sleep(10) и await asyncio.sleep(10)? Что произойдет с программой в каждом из случаев внутри асинхронной функции?

Вопрос: Можно ли внутри асинхронной функции (корутины) выполнять "тяжелые" вычисления? Если да, то как это сделать правильно, чтобы не заблокировать весь event loop?

Вопрос: Ребенок приходит к вам и говорит: "Я написал асинхронный парсер на asyncio и aiohttp, но почему-то он работает медленно и иногда зависает". Какая самая вероятная причина? (Подсказка: библиотеки).

Блок 4: Многопроцессорность (Multiprocessing)
Цель: Проверить понимание крайнего средства для CPU Bound.

Вопрос: Чем модуль multiprocessing принципиально отличается от threading с точки зрения памяти и GIL?

Вопрос: В чем главный недостаток многопроцессорности по сравнению с многопоточностью? Почему не стоит создавать 1000 процессов?

Вопрос: Как два процесса могут обмениваться данными? Назови хотя бы два способа из стандартной библиотеки.

Блок 5: Практические задачи (Задачи на подумать)
Цель: Увидеть, как ты применяешь теорию к реальному коду.

Задача: У тебя есть список из 100 ссылок на картинки. Тебе нужно скачать их все и сохранить на диск. Какой подход выберешь? (Последовательный, threading, asyncio, multiprocessing) и почему?

Задача: У тебя есть список из 100 CSV-файлов по 1 ГБ каждый. Тебе нужно посчитать сумму чисел в определенной колонке в каждом файле и вывести общий итог. Какой подход выберешь и почему?

Задача: Пишется веб-сервер на FastAPI (он асинхронный). Внутри одного эндпоинта нужно выполнить сложную математическую операцию, которая считает 5 секунд. Как это реализовать, чтобы сервер продолжал отвечать другим клиентам?

Блок 6: Вопросы "Звездочка" (Для самых смелых)
Тут можно блеснуть эрудицией, но база важнее.

Вопрос: Существуют ли библиотеки, которые позволяют обойти GIL в многопоточности? (Да, например, NumPy).

Вопрос: Что такое "проблема голодания" (starvation) в контексте потоков?

Попробуй ответить на эти вопросы письменно или устно. Если какой-то вопрос вызывает затруднение — это маркер, что тему стоит изучить чуть глубже. Удачи