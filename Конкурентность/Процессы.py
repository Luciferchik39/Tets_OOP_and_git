"""
Управление процессами это запрос от интерпритатора к системе ОС на устройсве!
Мы прописываем код и ПРОСИМ сисетму выполнить процесс (ИНИЦИИРУЕМ)

два основных типа задач
тяжелые вычисления (CPU bound)
конкурентный I/O (asyncio) задачи (Ввод/Вывод) I/O Bound (Сеть/Диск)

Процессор — это КТО выполняет (рабочий)
Процесс — это ЧТО выполняется (задача)
В контексте конкурентности:
Мы создаем процессы (задачи)
Операционная система назначает их на ядра процессора (исполнители)
Одно ядро может переключаться между разными процессами (конкурентность)
Несколько ядер могут выполнять разные процессы одновременно (параллелизм)
Теперь, когда ты читаешь про multiprocessing в Python, ты точно знаешь: этот модуль создает новые ПРОЦЕССЫ, которые ОС распределит по ЯДРАМ ПРОЦЕССОРА!

Когда ты знаешь, что обычный код — это один процесс на одном ядре, ты понимаешь:
Почему программа "зависает" — если одна функция долго работает, всё остальное ждет
Когда нужна конкурентность — если есть много ожидания (сеть, диск)
Когда нужен параллелизм — если есть тяжелые вычисления

пока ты не используешь специальные библиотеки для конкурентности, Python НИКОГДА не создает дополнительные процессы или потоки автоматически.
для всего обычного синхронного Python-кода, независимо от сложности структуры (классы, функции, циклы, условия)
"""
from multiprocessing import Process, Queue
import os
from time import sleep

a = print(f"начинаю работу в процессе {os.getpid()}")
sleep(10)




def worker(name):

    print(f"Дочерний процесс: {name}, PID: {os.getpid()}, родитель: {os.getppid()}")
    sleep(20)


def worker_two(q):
    result = 42
    print(f"Дочерний: я посчитал {result}")
    q.put(result)  # Отправляем результат в очередь




if __name__ == "__main__":  # ВАЖНО для Windows!
    print(f"Родительский процесс PID: {os.getpid()}")

    # Создаем дочерние процессы (аналог fork)
    # Process(target=функция, args=кортеж_с_аргументами)
    p1 = Process(target=worker, args=("Алиса",))
    p2 = Process(target=worker, args=("Боб",))

    p1.start()
    p2.start()

    p1.join()
    p2.join()

    q = Queue()
    p = Process(target=worker_two, args=(q,))
    p.start()

    # Обязательно ждем!
    p.join()
    # Только после join можно забрать результат
    result = q.get()
    print(f"Родитель: получил результат {result}")
